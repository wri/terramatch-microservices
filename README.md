# terramatch-microservices
Repository for the Microservices API backend of the TerraMatch service

# Requirements:
 * Node v20.11.1. Using [NVM](https://github.com/nvm-sh/nvm?tab=readme-ov-file) is recommended.
 * [Docker](https://www.docker.com/)
 * [CDK CLI](https://docs.aws.amazon.com/cdk/v2/guide/getting_started.html) (install globally)
 * [AWS SAM CLI](https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/install-sam-cli.html)
 * [NX](https://nx.dev/getting-started/installation#installing-nx-globally) (install globally)
 * [NestJS](https://docs.nestjs.com/) (install globally, useful for development)

# Building and starting the apps
 * Copy `.env.local.sample` to `.env`
 * The ApiGateway does not hot-reload and needs to be re-built when there are changes:
   * `nx build api-gateway` or `nx run-many -t build` (to build all apps)
   * This will build the local proxy Lambda function and the CDK Stack
 * To run all services:
   * `nx run-many -t serve`
   * Note: the first time this runs, the gateway will take quite awhile to start. It'll be faster on subsequent starts.
   * For now, this starts up the ApiGateway and the User service
 * In `.env` in your `wri-terramatch-website` repository, set your BE connection URL correctly:
   * `NEXT_PUBLIC_API_BASE_URL='http://localhost:4000'`

# Deployment
TBD. The ApiGateway has been tested to be at least functional on AWS. Tooling around deployment will be
handled in a future ticket.


# Database work
For now, Laravel is the source of truth for all things related to the DB schema. As such, TypeORM is not allowed to modify the 
schema, and is expected to interface with exactly the schema that is managed by Laravel. This note is included in user.entity.ts, 
and should hold true for all models created in this codebase until this codebase can take over as the source of truth for DB
schema:
```
// Note: this has some additional typing information (like width: 1 on bools and type: timestamps on
//   CreateDateColumn) to make the types generated here match what is generated by Laravel exactly.
//   At this time, we want TypeORM to expect exactly the same types that PHP uses by default. Tested
//   by checking what schema gets generated in the test database against the real DB during unit
//   test runs (the only time we let TypeORM modify the DB schema).
```

This codebase connects to the database running in the `wri-terramatch-api` docker container. The docker-compose
file included in this repo is used only for setting up the database needed for running unit tests in Github Actions.

# Testing
To set up the local testing database, run the `./bin/setup-test-database.sh` script. This script assumes that the
`wri-terramatch-api` project is checked out in the same parent directory as this one. The script may be run 
again at any time to clear out the test database records and schema.

`setup-jest.ts` is responsible for creating the Sequelize connection for all tests. Via the `sync` command, it also
creates database tables according to the schema declared in the `entity.ts` files in this codebase. Care should be
taken to make sure that the schema is set up in this codebase such that the database tables are created with the same
types and indices as in the primary database controlled by the Laravel backend. 

Factories may be used to create entries in the database for testing. See `user.factory.ts`, and uses of `UserFactory` for 
an example.

To run the tests for a single app/library:
* `nx test user-service` or `nx test common`

To run the tests for the whole codebase:
* `nx run-many -t test --passWithNoTests`

For checking coverage, simply pass the `--coverage` flag:
* `nx test user-service --coverage` or `nx run-many -t test --passWithNoTests --coverage`

For apps/libraries that have tests defined, the coverage thresholds are set for the whole project in `jest.preset.js`
